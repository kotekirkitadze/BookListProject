<div class="add-movie-container">
  <h1 class="title">{{"catalogue.searchPage.TITLE" | translate}}</h1>
  <div class="add-movie">
    <div class="form">
      <input [(ngModel)]="searchData"
             type="text"
             placeholder="{{'catalogue.searchPage.INPUT' | translate}}">
      <div class="error-box" *ngIf="errorVal">
        {{"errors.SEARCH_ERROR" | translate}}
      </div>
      <button (click)="searchBook(searchData)">{{"catalogue.searchPage.ADD_BOOK_BTN" | translate}}</button>
    </div>
  </div>
  <ul class="lastThree">
    <li *ngFor="let name of lastThreeSearches"
         (click)="getBooksFromApi(name)">
      {{name}}
    </li>
  </ul>
</div>
<form class="contact-box" [formGroup]="form">
  <div class="form-conatiner">
    <label>{{"catalogue.searchPage.REVIEW" | translate}}</label>
    <div class="input-div">
      <textarea type="text"
                class="textarea-field"
                formControlName="review"></textarea>
      <div *ngIf="form.invalid && submitted">
        <div *ngIf="form.controls.review?.errors && !form.controls.review?.errors?.minlength"
              class="alert">
          რევიუ სავალდებულოა
        </div>
        <div *ngIf="form.controls.review?.errors?.minlength" class="alert">
          თქვენი რევიუ მოკლეა
        </div>
      </div>
    </div>
  </div>
  <div class="form-conatiner form-conatiner">
    <label>{{"catalogue.searchPage.RATING" | translate}}</label>
    <div class="rating">
      <input type="radio"
             id="star1"
             [value]="5"
             formControlName="rating"><label for="star1"></label>
      <input type="radio"
             id="star2"
             [value]="4"
             formControlName="rating"><label for="star2"></label>
      <input type="radio"
             id="star3"
             [value]="3"
             formControlName="rating"><label for="star3"></label>
      <input type="radio"
             id="star4"
             [value]="2"
             formControlName="rating"><label for="star4"></label>
      <input type="radio"
             id="star5"
             [value]="1"
             formControlName="rating"><label for="star5"></label>
    </div>
  </div>
  <div class="form-conatiner">
    <label>{{"catalogue.searchPage.STATUS" | translate}}</label>
    <select formControlName="status">
      <option class="option"
              [ngValue]="status.Watched">{{"catalogue.searchPage.WATCHED" | translate}}</option>
      <option class="option"
              [ngValue]="status.WatchLater">{{"catalogue.searchPage.LATER_WATCH" | translate}}</option>
    </select>
  </div>
  <button type="button"
          (click)="submit()"
          class="btn btn-book">{{"catalogue.searchPage.ADD_COL" | translate}}</button>
</form>
<!-- <ng-container *ngIf="form.invalid && submitted">
  <div *ngIf="form.controls.review?.errors && !form.controls.review?.errors?.minlength">
    რევიუ სავალდებულოა
  </div>
  <div *ngIf="form.controls.review?.errors?.minlength">
    თქვენი რევიუ მოკლეა
  </div>
</ng-container> -->

<!-- ენგულარში ვალიდაციებისთვის გვაქვს გამზადებული და გვაქს ქასთომ
ვალიდატორებიც.
ფორმის შექმნა მეორე ნაირადაც შეიძლება ფორმბილდერებით:
this.form = this.fb.group({
  rating: 1,
  review: '',
  status: Status.WatchLater
});

this.form არ დაგვავიწყდეს რომ formGroup ის ტიპის არის.
ფორმბილდერით შექმნა ანალოგიუია -->

<!-- ვალიდატორების შექმნა:
this.form = new FormGroup({
  rating: new FormControl(3),
  review: new FormControl('', [Validators.required, Validators.minLength(10)]),
  status: new FormControl(Status.WatchLater)
}); -->

<!-- პ.ს. ყველაფერი ფორმებიდან იმპორტდება რასაც ვიყენებთ აქ. -->

<!-- და ვალიდაციების დაყენების შემდეგ რმ არასწრად მივუთითებთ,
this.form რომ დავბეჭდოთ ინვალიდ იქნება ტლიანი ფორმის სტატუსი,
და ობიექტში ერორებიც შეგვიძლია ვნახოთ, მინ ლენგზ ამდენია საჭირო და
შენ ამდენი გყავს შეყვანილი და სხვა ერორებიც კიდევ.
კონტროლებიც შეგვიძლია ვნახოთ სათითაოდ რამდენად ვალიდურია. -->


<!-- --- -->

<!-- ასე: <ng-container *ngIf="form.invalid">
  text
</ng-container> არ არის კარგი, რადგან თავიდანაც ჩანს
და რომ ავიცილოთ ეს თავიდან, შეგვიძლია ასე ჩავასწოროთ:

<ng-container *ngIf="form.invalid && form.dirty">
  text
</ng-container>

და დირთი ნიშნავს რომ თავიდან რაღაც ჩავწერეთ და მერე გვგდებს ერორს.
რომ არ ჩავწეროთ და უბრალდ დავაკლიკოთ და მერე ფოკუსი სხვა რამეზე გადავიტანოთ,
მაშინ არ გამოაჩენს ერორს დირთი.

დერთი და პრისტინი ერთმანეთის საპირისპიროა.
//დერთი ხდება თრუ, როცა წერას იწყებ.
//თაჩდი მაშინ ხდება თრუ, როცა დააკლიკავ. -->
<!--
თუ გვინდა ორმ საბმიტის დროს გამოჩნდეს რეაქტიული ფორმების გამოყეებისას,
მაშინ რამე ბულიან ცვლადი გავაკეთოთ დაენჯიიფში დამატებითად დავადოთ.
რაიმე, მაგალითად, საბმიტ მეთოდით გავხადოთ ეს ცვლადი თრუ და მივაბათ
კლიკზე საბმიტ ბათონს თემფლეითში. აქ სხვადასხვა ნიუანსებია კიდევ
გასათვალისწინებელი, მაგალითად, დაკლიკვის შემდეგ ცვლადი სულ თრუ არის და
დირთის გახდომის შემდეგ სულ ამვარდება ერორი.

მაგრამ უკეთესი ერორ ჰენდლინგი საბმითის დროს რომ გამოჩნდეს,
თემფლეით დრივენ ფრმებშიაო.

ფორმის ობიექტს შიგნით აქვს კიდევ ფორმ კონტროლები, რომლებსაც რაღაც ველიუები აქვთ, რაც
კოტრნოლებს ახასიათებთ. მაგალითად, ფორმკონტროლების ერორები, ონჩეინჯი და ასე შემდეგ. -->

<!--
რევუ სავალდებულო რომ დავაბეჭდინოთ, თან დირთი მოვაშოროთ,
რომ უფრო ფრენდლი იყოს და ასევე რევუ თუ შეივსო რაღაცით და
მინიმალური მნიშვნელობაც რომ დავბეჭდოთ.
მინიმალური მნიშვნელობის დაბეჭვდის გამო, რექუაირედ ველიუს
ცალკე ვალიდაცია დავამატე და დააკვირდი რომ ნახავ კიდევ:
<ng-container *ngIf="form.invalid && submitted">
  <div *ngIf="form.controls.review?.errors && !form.controls.review?.errors?.minlength">
    რევიუ სავალდებულოა
  </div>
  <div *ngIf="form.controls.review?.errors?.minlength">
    თქვენი რევიუ მოკლეა
  </div>
</ng-container> -->



<!--
Validators.min - ციფრებზე ამოწმებს.
Validators.pattern - პატერების შემოწმება შეგვიძლია, იმეილის ან რამე მსგავსის.
                      რეჯექსების მიცემა შეგვიძლია პატერნის.
იმეილს ვალიდატორი ცალკეა: Validators.email


formBuilder - ებში ვალიდაცია კი ასე ხდება:
this.form = this.fb.group({
  rating: 1,
  review: ['', Validators.required, Validators.minLength(10)],
  status: Status.WatchLater
}); -->

<!-- რეაქტიულობა შეგვიძლია აქ დავინახოთ ველიუ ჩეინების ობზერვებლით:
this.form.valueChanges.subscribe(form => console.log(form));

this.form.get("review").valueChanges.subscribe(review=>console.log(review));

პ.ს. ველიუ ჩეინჯებს ანსაბსქრაიბი უნდა გავუკეთოთ ხოლმე.
ფორმის კონტროლებზე ანსაბსქრაიბი გვინდა, რადგან თავისით არ ქომფლითდება.
მემორი ლიქებს რომ ავცდეთ.


ანსაბსქრაიბების გაკეთების გზები:

პიველი გზა:
შევქმნათ საბსქრიშენების ერეი, შემდეგ ობზერვებლები
რომ გვიბრუნებს საბსქრაიბის შემდეგ საბსქრიფშენებს მივამანიჭოთ რამე ცვლადს
და ეს ცვლადები ჩავფუშოთ საბსქრიფშენების ერეიში და ონჯიდესტროიში
ფორიჩით გადავუაროთ და ანსაბსქრაიბი გავუკეთოთ.

subs: Subscription[];

const subscriberOne =  this.form.valueChanges.subscribe(form => console.log(form));

    const subscriberTwo = this.form.get("review").valueChanges.subscribe(review=>console.log(review));

    this.subs.push(subscriberOne);
    this.subs.push(subscriberTwo);

    ngOnDestroy(){
      this.subs.forEach(element => element.unsubscribe());
    }

მაგრამ ეს გზა ხშირად არ გამოიყენება. რაღაც პრობლემებს ქმნის ასინქრონულობასთან დაკავშირებით და
//კომპონენტებში რაღაცეებს ურევს ხოლმე თანო.  -->

<!-- ველიუ ჩეინჯებით შეიძლება კალკულატორის აწყობა -->
<!-- ასევე, გვაქვს მეორე გზაც, რომელსაც უფრო ხშირად გამოიყენებენ და
უკეთესი პრაქტიკაა:
თეიქანთილ ფაიფის გამოყენება:
private unsubscribe$ = new Subject();

this.form.valueChanges.pipe(takeUntil(this.unsubscribe$)).subscribe(form => console.log(form));


ngOnDestroy(){
  this.unsubscribe$.next();
  this.unsubscribe$.complete();
 } -->






<!-- რეაქტივ ფორმების ქასთომ ვალიდატორი -->
<!--
review: new FormControl('', [Validators.required,
Validators.minLength(10),
isTextKote()]),


function isTextKote(): ValidatorFn  {
  return (control: FormControl) => {
    if(control.value === "kote"){
      return null;
    } else {
      return { customError: "Text is not kote"}
    }
  }
}

ამ ვალიდატორში თუ ყველაფერი რიგზეა დააბრუნებს ნალს customError: null
და ფორმის ინვალიდი იქნება ფოლსი.

და კლასის გარეთ ვწერთ ამ ქასთომ ვალიდატორ ფუნქციას.


ასევე, ლოგიკაში თემფლეითში თუ გვინდა მივწვდეთ ქასთომ ერორს,
 return { customError: "Text is not kote"} დან customError? უნდა ავღოთ,
 რაც ქასთომად გავწერეთ.
 -->






 <!-- template Driven ფორმების ვალიდაცია -->
 <!-- რეაქტივ ფორმებში ფორმის ტიპი იყო formGroup
 და თემფლეით დრივენში კი არის ngForm
 და შიგნით აქვს ფრომგრუპი.  -->

 <!-- //ასევე, თემფლეით დრივენ ფორმები ავტომატურად აკეთებს
 //ფორმების შეკვრას, რაც ჩვენ ვქენით ხელით რეაქტული ფორმების დროს. -->
 <!-- NgForm - იდანაც შეგვიძლია ამოვღოთ ერორები, დავსუსაბსქრაიბდეთ და ასე შემდეგ,
 მაგრამ ეს ართულებს და ბევრი წვალება გვჭირდება. რადგან ენჯიფორმის ვრაპერი
 თვითონ ტიესში არ გვაქვს და რაღაცეების ჩალიჩი მოგვიწევს(ვიუ ჩაილდის აღება და ასე შემდეგ).
 თემფლეით დრივენ ფორმები არაა გათვლილი რომ ენჯფრომების ელემენტებს
 დავუსაბსქრაიბდეთ და რაღაცეები ვაკეთოთ.

 <ng-container *ngIf="signInFromData.submitted && signInFromData.invalid">
  <div *ngIf="signInFromData.controls.review.errors && !signInFromData.controls.review.errors.minlength">
       რევიუ სავალდებულოა
  </div>
  <div *ngIf="signInFromData.controls.review.errors.minlength">
      თქვენი რევიუ მოკლეა
  </div>
</ng-container>

და აქ თუ დავაკვირდებით საბმითიდ ენჯი ფორმას თვითონ აქვს. რეაქტივის დროს
ჩვენ შევქმენით ბულეან ცვლადი, რომელიც ინდიკატორი იყო ჩვენთვის,
ფორმა დასაბმითდა თუ არა. -->


<!--
<ng-container *ngIf="signInFromData.submitted && signInFromData.invalid">
  <div *ngIf="signInFromData.controls.email?.errors?.required">

    აქ ფორმა შეიძება იყოს ინვალიდი და კონტროლები შეიძლება არა ამავე დროს,
    ამიტომ გავუწერეთ email?.errors? ერორსაც ვალიდაცია აქ. -->

<!--
ქასთომ ვალიდატორი თემფლეით დრივენ ფორმებში:
აქ უფრო რთულად ხდება, რადგან აქ ფუნქციის დაწრაც გვიწევს და ასევე დირექტივის,
რადგან თემფლეითზე როგორღაც უნდა დავდოთ და დადების ერთადერთი გზა არის დირექტივა.

ორი ტიეს ფაილი შევქმენით, ერთი ვალიდატორი, მეორე დირექტივა და
ეს დირექტივა გადის ვალიდატორის ფუნქციაზე და ამ დირექტივას ვადებთ
თემფლეით დრივენ ფორმას. რადგან თემფელითიდან გასვლის მექანიზმი დირექტივაა.
მერე ლოგიკის დაწერა თითქმის იგივეა, როგორც რეაქტიულ ფორმებში.  -->
